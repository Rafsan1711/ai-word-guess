<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced AI Word Master</title>
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <!-- Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.22.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.1/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script>
    
    <!-- CSS Modules -->
    <style id="base-css">
        /* base.css */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-primary: #30363d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #238636;
            --accent-yellow: #9e6a03;
            --accent-red: #f85149;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        button {
            cursor: pointer;
            border: none;
            outline: none;
            transition: all 0.3s ease;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>

    <style id="home-css">
        /* home.css */
        #homeScreen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
        }

        .game-title {
            font-size: 4rem;
            font-weight: 800;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(88, 166, 255, 0.3);
            animation: titleGlow 2s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .game-subtitle {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 40px;
            letter-spacing: 2px;
        }

        .difficulty-selector {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
        }

        .difficulty-btn {
            padding: 15px 30px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-primary);
            color: var(--text-primary);
            border-radius: 10px;
            font-weight: 600;
            font-size: 1rem;
        }

        .difficulty-btn.active {
            border-color: var(--accent-blue);
            background: linear-gradient(135deg, #1f6feb 0%, #58a6ff 100%);
            color: white;
        }

        .home-buttons {
            display: flex;
            gap: 30px;
        }

        .home-btn {
            padding: 20px 50px;
            font-size: 1.3rem;
            font-weight: 600;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .btn-play {
            background: linear-gradient(135deg, var(--accent-green) 0%, #2ea043 100%);
            color: white;
            box-shadow: 0 0 20px rgba(46, 160, 67, 0.4);
        }

        .btn-play:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 30px rgba(46, 160, 67, 0.6);
        }

        .btn-ai {
            background: linear-gradient(135deg, #1f6feb 0%, var(--accent-blue) 100%);
            color: white;
            box-shadow: 0 0 20px rgba(31, 111, 235, 0.4);
        }

        .btn-ai:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 30px rgba(31, 111, 235, 0.6);
        }

        .stats-preview {
            margin-top: 40px;
            padding: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            text-align: center;
        }

        .stats-preview h3 {
            color: var(--accent-blue);
            margin-bottom: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }

        .stat-item {
            padding: 10px;
        }

        .stat-item .value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-blue);
        }

        .stat-item .label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
    </style>

    <style id="game-css">
        /* game.css */
        .game-screen {
            display: none;
            padding-top: 40px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .back-btn {
            padding: 10px 20px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-primary);
            border-radius: 8px;
        }

        .back-btn:hover {
            background: var(--border-primary);
            border-color: var(--accent-blue);
        }

        .game-title-small {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-blue);
        }

        .game-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .difficulty-badge {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            font-weight: 600;
        }

        .difficulty-badge.easy { border-color: #2ea043; color: #2ea043; }
        .difficulty-badge.medium { border-color: #58a6ff; color: #58a6ff; }
        .difficulty-badge.hard { border-color: #9e6a03; color: #9e6a03; }
        .difficulty-badge.expert { border-color: #f85149; color: #f85149; }

        /* Grid */
        .grid-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 0 auto 30px;
            width: fit-content;
        }

        .grid-row {
            display: flex;
            gap: 8px;
        }

        .grid-cell {
            width: 70px;
            height: 70px;
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: 700;
            text-transform: uppercase;
            background: var(--bg-secondary);
            transition: all 0.3s;
        }

        .grid-cell.filled {
            border-color: var(--accent-blue);
            transform: scale(1.05);
        }

        .grid-cell.correct {
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: white;
        }

        .grid-cell.present {
            background: var(--accent-yellow);
            border-color: var(--accent-yellow);
            color: white;
        }

        .grid-cell.absent {
            background: var(--border-primary);
            border-color: var(--border-primary);
            color: #6e7681;
        }

        .error-message {
            text-align: center;
            color: var(--accent-red);
            font-weight: 600;
            padding: 10px;
            margin: 10px auto;
            max-width: 400px;
            background: rgba(248, 81, 73, 0.1);
            border: 1px solid var(--accent-red);
            border-radius: 8px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .error-message.show { opacity: 1; }

        .game-status {
            text-align: center;
            padding: 30px;
            margin: 20px 0;
            border-radius: 12px;
            display: none;
        }

        .game-status.active { display: block; }

        .game-status.win {
            background: rgba(35, 134, 54, 0.2);
            border: 2px solid var(--accent-green);
        }

        .game-status.lose {
            background: rgba(248, 81, 73, 0.2);
            border: 2px solid var(--accent-red);
        }

        .status-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .status-word {
            font-size: 1.5rem;
            margin-top: 10px;
            color: var(--text-secondary);
        }

        .play-again-btn {
            margin-top: 20px;
            padding: 12px 30px;
            background: var(--accent-green);
            color: white;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .play-again-btn:hover {
            background: #2ea043;
            transform: translateY(-2px);
        }
    </style>

    <style id="keyboard-css">
        /* keyboard.css */
        .keyboard {
            max-width: 600px;
            margin: 0 auto;
        }

        .keyboard-row {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
            justify-content: center;
        }

        .key {
            padding: 15px;
            min-width: 45px;
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .key:hover:not(:disabled) {
            background: var(--border-primary);
            transform: translateY(-2px);
        }

        .key.wide {
            min-width: 80px;
            font-size: 0.85rem;
        }

        .key.correct {
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: white;
        }

        .key.present {
            background: var(--accent-yellow);
            border-color: var(--accent-yellow);
            color: white;
        }

        .key.absent {
            background: var(--border-primary);
            border-color: var(--border-primary);
            color: #6e7681;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .key.disabled {
            pointer-events: none;
        }
    </style>

    <style id="analytics-css">
        /* analytics.css */
        .ai-thinking {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            display: none;
        }

        .ai-thinking.active { display: block; }

        .thinking-text {
            font-size: 1.2rem;
            color: var(--accent-blue);
            margin-bottom: 10px;
        }

        .thinking-dots span {
            display: inline-block;
            animation: thinking 1.4s infinite;
            font-size: 2rem;
            color: var(--accent-blue);
        }

        .thinking-dots span:nth-child(2) { animation-delay: 0.2s; }
        .thinking-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes thinking {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }

        .ai-analytics-section {
            margin-top: 40px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out;
        }

        .ai-analytics-section.expanded { max-height: 5000px; }

        .analytics-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 16px;
            padding: 30px;
            margin-top: 20px;
        }

        .analytics-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent-blue);
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s;
        }

        .stat-card:hover {
            border-color: var(--accent-blue);
            transform: translateY(-5px);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--accent-blue);
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .graphs-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }

        .graph-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 20px;
        }

        .graph-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .graph {
            min-height: 300px;
        }

        .neural-viz {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .neural-viz canvas {
            width: 100%;
            height: 400px;
        }
    </style>

    <style id="achievements-css">
        /* achievements.css */
        .achievements-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 300px;
        }

        .achievement-notification {
            background: linear-gradient(135deg, var(--accent-green) 0%, #2ea043 100%);
            border: 2px solid #2ea043;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
            color: white;
            box-shadow: 0 5px 20px rgba(46, 160, 67, 0.5);
            animation: slideIn 0.5s ease-out;
            display: none;
        }

        .achievement-notification.show {
            display: block;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .achievement-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .achievement-title {
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 5px;
        }

        .achievement-desc {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .achievements-list {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 20px;
            margin-top: 30px;
        }

        .achievement-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            margin-bottom: 10px;
            transition: all 0.3s;
        }

        .achievement-item.unlocked {
            border-color: var(--accent-green);
        }

        .achievement-item.locked {
            opacity: 0.5;
        }

        .achievement-item:hover {
            transform: translateX(5px);
        }
    </style>

    <style id="animations-css">
        /* animations.css */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        .shake {
            animation: shake 0.5s;
        }

        @keyframes flip {
            0% {
                transform: rotateX(0);
            }
            50% {
                transform: rotateX(90deg);
            }
            100% {
                transform: rotateX(0);
            }
        }

        .flip {
            animation: flip 0.6s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        .pulse {
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .gear {
            animation: rotate 3s linear infinite;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .slide-up {
            animation: slideUp 0.5s ease-out;
        }

        /* Particle System */
        .particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--accent-blue);
            border-radius: 50%;
            animation: float 3s infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0) translateX(0);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .game-title {
                font-size: 2.5rem;
            }
            
            .home-buttons {
                flex-direction: column;
            }
            
            .grid-cell {
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
            }
            
            .key {
                padding: 12px;
                min-width: 35px;
                font-size: 0.9rem;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .achievements-panel {
                right: 10px;
                left: 10px;
                max-width: none;
            }
        }
    </style>
</head>
<body>
    <!-- Achievement Notifications -->
    <div class="achievements-panel">
        <div class="achievement-notification" id="achievementNotif">
            <div class="achievement-icon"></div>
            <div class="achievement-title"></div>
            <div class="achievement-desc"></div>
        </div>
    </div>

    <!-- Home Screen -->
    <div id="homeScreen">
        <h1 class="game-title">WORD MASTER AI</h1>
        <p class="game-subtitle">ADVANCED AI-POWERED WORD GUESSING</p>
        
        <div class="difficulty-selector">
            <button class="difficulty-btn active" data-difficulty="easy" onclick="selectDifficulty('easy')">
                <i class="fas fa-smile"></i> EASY
            </button>
            <button class="difficulty-btn" data-difficulty="medium" onclick="selectDifficulty('medium')">
                <i class="fas fa-meh"></i> MEDIUM
            </button>
            <button class="difficulty-btn" data-difficulty="hard" onclick="selectDifficulty('hard')">
                <i class="fas fa-fire"></i> HARD
            </button>
            <button class="difficulty-btn" data-difficulty="expert" onclick="selectDifficulty('expert')">
                <i class="fas fa-skull"></i> EXPERT
            </button>
        </div>

        <div class="home-buttons">
            <button class="home-btn btn-play" onclick="startGame('human')">
                <i class="fas fa-play"></i> PLAY
            </button>
            <button class="home-btn btn-ai" onclick="startGame('ai')">
                <i class="fas fa-robot"></i> WATCH AI
            </button>
        </div>

        <div class="stats-preview">
            <h3><i class="fas fa-chart-line"></i> Global AI Statistics</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="value" id="globalGames">0</div>
                    <div class="label">Total Games</div>
                </div>
                <div class="stat-item">
                    <div class="value" id="globalWinRate">0%</div>
                    <div class="label">Win Rate</div>
                </div>
                <div class="stat-item">
                    <div class="value" id="globalAvgGuesses">0</div>
                    <div class="label">Avg Guesses</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Human Game Screen -->
    <div id="humanScreen" class="game-screen">
        <div class="container">
            <div class="game-header">
                <button class="back-btn" onclick="goHome()">
                    <i class="fas fa-arrow-left"></i> Back
                </button>
                <h2 class="game-title-small">YOUR TURN</h2>
                <div class="game-info">
                    <div class="difficulty-badge" id="humanDifficulty">MEDIUM</div>
                </div>
            </div>

            <div class="error-message" id="humanError"></div>
            <div class="grid-container" id="humanGrid"></div>

            <div class="game-status" id="humanStatus">
                <div class="status-title"></div>
                <div class="status-word"></div>
                <button class="play-again-btn" onclick="resetGame('human')">Play Again</button>
            </div>

            <div class="keyboard" id="keyboard"></div>

            <!-- Achievements Section -->
            <div class="achievements-list" id="humanAchievements">
                <h3 style="color: var(--accent-blue); margin-bottom: 20px;">
                    <i class="fas fa-trophy"></i> Your Achievements
                </h3>
                <div id="achievementsList"></div>
            </div>
        </div>
    </div>

    <!-- AI Game Screen -->
    <div id="aiScreen" class="game-screen">
        <div class="container">
            <div class="game-header">
                <button class="back-btn" onclick="goHome()">
                    <i class="fas fa-arrow-left"></i> Back
                </button>
                <h2 class="game-title-small">AI SOLVER</h2>
                <button class="home-btn btn-ai" onclick="toggleAnalytics()" style="padding: 10px 20px; font-size: 1rem;">
                    <i class="fas fa-chart-line"></i> <span id="analyticsToggleText">Show Analytics</span>
                </button>
            </div>

            <div class="ai-thinking" id="aiThinking">
                <div class="thinking-text">AI is analyzing...</div>
                <div class="thinking-dots">
                    <span>‚óè</span>
                    <span>‚óè</span>
                    <span>‚óè</span>
                </div>
            </div>

            <div class="grid-container" id="aiGrid"></div>

            <div class="game-status" id="aiStatus">
                <div class="status-title"></div>
                <div class="status-word"></div>
                <button class="play-again-btn" onclick="resetGame('ai')">Watch Again</button>
            </div>

            <!-- AI Analytics -->
            <div class="ai-analytics-section" id="aiAnalytics">
                <div class="analytics-content">
                    <h2 class="analytics-title">
                        <i class="fas fa-brain"></i> AI ANALYTICS & NEURAL NETWORK
                    </h2>

                    <!-- Neural Network Visualization -->
                    <div class="neural-viz">
                        <h3 style="color: var(--accent-blue); margin-bottom: 20px;">
                            <i class="fas fa-project-diagram"></i> Neural Network Decision Process
                        </h3>
                        <canvas id="neuralCanvas"></canvas>
                    </div>

                    <div class="stats-container">
                        <div class="stat-card">
                            <div class="stat-value" id="gamesPlayed">0</div>
                            <div class="stat-label">Games Played</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="winRate">0%</div>
                            <div class="stat-label">Win Rate</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="avgGuesses">0</div>
                            <div class="stat-label">Avg Guesses</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="learningRate">0%</div>
                            <div class="stat-label">Learning Progress</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="strategyScore">0</div>
                            <div class="stat-label">Strategy Score</div>
                        </div>
                    </div>

                    <div class="graphs-container">
                        <div class="graph-card">
                            <div class="graph-title">
                                <i class="fas fa-chart-bar"></i> Word Probability Distribution
                            </div>
                            <div class="graph" id="probabilityGraph"></div>
                        </div>

                        <div class="graph-card">
                            <div class="graph-title">
                                <i class="fas fa-chart-line"></i> AI Performance Over Time
                            </div>
                            <div class="graph" id="performanceGraph"></div>
                        </div>

                        <div class="graph-card">
                            <div class="graph-title">
                                <i class="fas fa-network-wired"></i> Letter Frequency Heatmap
                            </div>
                            <div class="graph" id="letterHeatmap"></div>
                        </div>

                        <div class="graph-card">
                            <div class="graph-title">
                                <i class="fas fa-brain"></i> Strategy Effectiveness
                            </div>
                            <div class="graph" id="strategyGraph"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript Modules -->
    <script>
        // ============================================
        // config.js - Game Configuration
        // ============================================
        const CONFIG = {
            WORDS: {
                easy: ['apple', 'house', 'water', 'happy', 'music', 'dance', 'smile', 'peace', 'light', 'green'],
                medium: ['about', 'above', 'admit', 'agent', 'album', 'alert', 'alive', 'allow', 'alone', 'along'],
                hard: ['acute', 'argue', 'asset', 'audit', 'avoid', 'award', 'aware', 'badly', 'beach', 'began'],
                expert: ['craft', 'chaos', 'proxy', 'crypt', 'lymph', 'nymph', 'psych', 'synth', 'tryst', 'glyph']
            },
            MAX_GUESSES: 6,
            WORD_LENGTH: 5,
            AI_THINK_TIME: {
                min: 1000,
                max: 2500
            },
            DIFFICULTY_MULTIPLIERS: {
                easy: 1.5,
                medium: 1.0,
                hard: 0.8,
                expert: 0.6
            }
        };

        // Extended word lists
        const EXTENDED_WORDS = [
            'about', 'above', 'abuse', 'actor', 'acute', 'admit', 'adopt', 'adult', 'after', 'again',
            'agent', 'agree', 'ahead', 'alarm', 'album', 'alert', 'alike', 'alive', 'allow', 'alone',
            'along', 'alter', 'among', 'anger', 'angle', 'angry', 'apart', 'apple', 'apply', 'arena',
            'argue', 'arise', 'array', 'aside', 'asset', 'audio', 'audit', 'avoid', 'award', 'aware',
            'badly', 'baker', 'basic', 'beach', 'began', 'begin', 'being', 'below', 'bench', 'birth',
            'black', 'blame', 'blind', 'block', 'blood', 'board', 'boost', 'bound', 'brain', 'brand',
            'bread', 'break', 'breed', 'brief', 'bring', 'broad', 'broke', 'brown', 'build', 'built',
            'cable', 'carry', 'catch', 'cause', 'chain', 'chair', 'chart', 'chase', 'cheap', 'check',
            'chest', 'chief', 'child', 'china', 'chose', 'civil', 'claim', 'class', 'clean', 'clear',
            'click', 'clock', 'close', 'coach', 'coast', 'could', 'count', 'court', 'cover', 'craft',
            'crash', 'crazy', 'cream', 'crime', 'cross', 'crowd', 'crown', 'crude', 'cycle', 'daily',
            'dance', 'dealt', 'death', 'debut', 'delay', 'depth', 'doing', 'doubt', 'dozen', 'draft',
            'drama', 'drank', 'drawn', 'dream', 'dress', 'drill', 'drink', 'drive', 'drove', 'dying',
            'eager', 'early', 'earth', 'eight', 'elite', 'empty', 'enemy', 'enjoy', 'enter', 'entry',
            'equal', 'error', 'event', 'every', 'exact', 'exist', 'extra', 'faith', 'false', 'fault',
            'fiber', 'field', 'fifth', 'fifty', 'fight', 'final', 'first', 'fixed', 'flash', 'fleet',
            'floor', 'fluid', 'focus', 'force', 'forth', 'forty', 'forum', 'found', 'frame', 'frank',
            'fraud', 'fresh', 'front', 'fruit', 'fully', 'funny', 'giant', 'given', 'glass', 'globe',
            'going', 'grace', 'grade', 'grand', 'grant', 'grass', 'great', 'green', 'gross', 'group',
            'grown', 'guard', 'guess', 'guest', 'guide', 'happy', 'heart', 'heavy', 'hence', 'horse',
            'hotel', 'house', 'human', 'ideal', 'image', 'index', 'inner', 'input', 'issue', 'japan',
            'joint', 'jones', 'judge', 'known', 'label', 'large', 'laser', 'later', 'laugh', 'layer',
            'learn', 'lease', 'least', 'leave', 'legal', 'lemon', 'level', 'lewis', 'light', 'limit',
            'links', 'lives', 'local', 'logic', 'loose', 'lower', 'lucky', 'lunch', 'lying', 'magic',
            'major', 'maker', 'march', 'maria', 'match', 'maybe', 'mayor', 'meant', 'media', 'metal',
            'might', 'minor', 'minus', 'mixed', 'model', 'money', 'month', 'moral', 'motor', 'mount',
            'mouse', 'mouth', 'movie', 'music', 'needs', 'never', 'newly', 'night', 'noise', 'north',
            'noted', 'novel', 'nurse', 'ocean', 'offer', 'often', 'order', 'other', 'ought', 'paint',
            'panel', 'paper', 'party', 'peace', 'peter', 'phase', 'phone', 'photo', 'piece', 'pilot',
            'pitch', 'place', 'plain', 'plane', 'plant', 'plate', 'point', 'pound', 'power', 'press',
            'price', 'pride', 'prime', 'print', 'prior', 'prize', 'proof', 'proud', 'prove', 'queen',
            'quick', 'quiet', 'quite', 'radio', 'raise', 'range', 'rapid', 'ratio', 'reach', 'ready',
            'refer', 'right', 'rival', 'river', 'robin', 'roger', 'roman', 'rough', 'round', 'route',
            'royal', 'rural', 'scale', 'scene', 'scope', 'score', 'sense', 'serve', 'seven', 'shall',
            'shape', 'share', 'sharp', 'sheet', 'shelf', 'shell', 'shift', 'shine', 'shirt', 'shock',
            'shoot', 'short', 'shown', 'sight', 'since', 'sixth', 'sixty', 'sized', 'skill', 'sleep',
            'slide', 'small', 'smart', 'smile', 'smith', 'smoke', 'solid', 'solve', 'sorry', 'sound',
            'south', 'space', 'spare', 'speak', 'speed', 'spend', 'spent', 'split', 'spoke', 'sport',
            'staff', 'stage', 'stake', 'stand', 'start', 'state', 'steam', 'steel', 'stick', 'still',
            'stock', 'stone', 'stood', 'store', 'storm', 'story', 'strip', 'stuck', 'study', 'stuff',
            'style', 'sugar', 'suite', 'super', 'sweet', 'table', 'taken', 'taste', 'taxes', 'teach',
            'teeth', 'terry', 'texas', 'thank', 'theft', 'their', 'theme', 'there', 'these', 'thick',
            'thing', 'think', 'third', 'those', 'three', 'threw', 'throw', 'tight', 'times', 'title',
            'today', 'topic', 'total', 'touch', 'tough', 'tower', 'track', 'trade', 'train', 'treat',
            'trend', 'trial', 'tribe', 'trick', 'tried', 'tries', 'troop', 'truck', 'truly', 'trump',
            'trust', 'truth', 'twice', 'under', 'undue', 'union', 'unity', 'until', 'upper', 'upset',
            'urban', 'usage', 'usual', 'valid', 'value', 'video', 'virus', 'visit', 'vital', 'vocal',
            'voice', 'waste', 'watch', 'water', 'wheel', 'where', 'which', 'while', 'white', 'whole',
            'whose', 'woman', 'women', 'world', 'worry', 'worse', 'worst', 'worth', 'would', 'wound',
            'write', 'wrong', 'wrote', 'young', 'youth'
        ];

        // Combine all word lists
        const ALL_WORDS = [...new Set([
            ...EXTENDED_WORDS,
            ...CONFIG.WORDS.easy,
            ...CONFIG.WORDS.medium,
            ...CONFIG.WORDS.hard,
            ...CONFIG.WORDS.expert
        ])];

        // ============================================
        // firebase-config.js - Firebase Setup
        // ============================================
        const firebaseConfig = {
  apiKey: "AIzaSyDQugAaucGe4UtYdjrZDeNBzdrXosQVUQ8",
  authDomain: "rating-system-c7adc.firebaseapp.com",
  projectId: "rating-system-c7adc",
  storageBucket: "rating-system-c7adc.firebasestorage.app",
  messagingSenderId: "876647083847",
  appId: "1:876647083847:web:11cac4f4c52a2f9babe662",
  measurementId: "G-S5VR126WCL"
        };

        // Initialize Firebase
        let database = null;
        let isFirebaseEnabled = false;

        try {
            firebase.initializeApp(firebaseConfig);
            database = firebase.database();
            isFirebaseEnabled = true;
            console.log('‚úÖ Firebase initialized successfully');
        } catch (error) {
            console.warn('‚ö†Ô∏è Firebase not configured. Using local storage only.');
            isFirebaseEnabled = false;
        }

        // ============================================
        // storage.js - Data Storage Manager
        // ============================================
        const StorageManager = {
            // Save to Firebase
            async saveToFirebase(path, data) {
                if (!isFirebaseEnabled) return;
                try {
                    await database.ref(path).set(data);
                } catch (error) {
                    console.error('Firebase save error:', error);
                }
            },

            // Load from Firebase
            async loadFromFirebase(path) {
                if (!isFirebaseEnabled) return null;
                try {
                    const snapshot = await database.ref(path).once('value');
                    return snapshot.val();
                } catch (error) {
                    console.error('Firebase load error:', error);
                    return null;
                }
            },

            // Update Firebase incrementally
            async updateFirebase(path, data) {
                if (!isFirebaseEnabled) return;
                try {
                    await database.ref(path).update(data);
                } catch (error) {
                    console.error('Firebase update error:', error);
                }
            },

            // Local Storage fallback
            saveLocal(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                } catch (error) {
                    console.error('LocalStorage save error:', error);
                }
            },

            loadLocal(key) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : null;
                } catch (error) {
                    console.error('LocalStorage load error:', error);
                    return null;
                }
            },

            // Save AI progress
            async saveAIProgress(data) {
                await this.saveToFirebase('aiProgress', data);
                this.saveLocal('aiProgress', data);
            },

            // Load AI progress
            async loadAIProgress() {
                const firebaseData = await this.loadFromFirebase('aiProgress');
                if (firebaseData) return firebaseData;
                return this.loadLocal('aiProgress');
            },

            // Save global stats
            async saveGlobalStats(stats) {
                await this.updateFirebase('globalStats', stats);
            },

            // Load global stats
            async loadGlobalStats() {
                return await this.loadFromFirebase('globalStats') || {
                    totalGames: 0,
                    totalWins: 0,
                    totalGuesses: 0
                };
            }
        };

        // ============================================
        // game-state.js - Game State Manager
        // ============================================
        let gameState = {
            mode: 'human',
            difficulty: 'medium',
            targetWord: '',
            currentRow: 0,
            currentGuess: '',
            guesses: [],
            gameOver: false,
            keyboardState: {},
            clues: {
                correct: {},      // {position: letter}
                present: new Set(), // letters in word but wrong position
                absent: new Set()   // letters not in word
            }
        };

        let aiState = {
            model: null,
            gamesPlayed: 0,
            wins: 0,
            totalGuesses: 0,
            performanceHistory: [],
            wordScores: {},
            letterFrequency: {},
            positionFrequency: {},
            currentProbabilities: [],
            strategyEffectiveness: {
                positionBased: 0,
                frequencyBased: 0,
                eliminationBased: 0
            }
        };

        // ============================================
        // achievements.js - Achievement System
        // ============================================
        const Achievements = {
            list: [
                {
                    id: 'first_win',
                    title: 'First Victory',
                    description: 'Win your first game',
                    icon: 'üéâ',
                    unlocked: false
                },
                {
                    id: 'perfect_game',
                    title: 'Perfect Game',
                    description: 'Win in 3 guesses or less',
                    icon: '‚≠ê',
                    unlocked: false
                },
                {
                    id: 'streak_5',
                    title: 'Winning Streak',
                    description: 'Win 5 games in a row',
                    icon: 'üî•',
                    unlocked: false
                },
                {
                    id: 'veteran',
                    title: 'Veteran Player',
                    description: 'Play 50 games',
                    icon: 'üèÜ',
                    unlocked: false
                },
                {
                    id: 'expert_solver',
                    title: 'Expert Solver',
                    description: 'Beat expert difficulty',
                    icon: 'üíé',
                    unlocked: false
                },
                {
                    id: 'speed_demon',
                    title: 'Speed Demon',
                    description: 'Win in under 30 seconds',
                    icon: '‚ö°',
                    unlocked: false
                }
            ],

            check(achievementId) {
                const achievement = this.list.find(a => a.id === achievementId);
                if (achievement && !achievement.unlocked) {
                    achievement.unlocked = true;
                    this.showNotification(achievement);
                    this.save();
                }
            },

            showNotification(achievement) {
                const notif = document.getElementById('achievementNotif');
                notif.querySelector('.achievement-icon').textContent = achievement.icon;
                notif.querySelector('.achievement-title').textContent = achievement.title;
                notif.querySelector('.achievement-desc').textContent = achievement.description;
                notif.classList.add('show');

                setTimeout(() => {
                    notif.classList.remove('show');
                }, 4000);
            },

            render() {
                const container = document.getElementById('achievementsList');
                container.innerHTML = this.list.map(a => `
                    <div class="achievement-item ${a.unlocked ? 'unlocked' : 'locked'}">
                        <div style="font-size: 2rem;">${a.icon}</div>
                        <div style="flex: 1;">
                            <div style="font-weight: 700; color: ${a.unlocked ? 'var(--accent-green)' : 'var(--text-secondary)'};">
                                ${a.title}
                            </div>
                            <div style="font-size: 0.9rem; color: var(--text-secondary);">
                                ${a.description}
                            </div>
                        </div>
                        ${a.unlocked ? '<i class="fas fa-check" style="color: var(--accent-green); font-size: 1.5rem;"></i>' : '<i class="fas fa-lock" style="color: var(--text-secondary);"></i>'}
                    </div>
                `).join('');
            },

            save() {
                StorageManager.saveLocal('achievements', this.list);
            },

            load() {
                const saved = StorageManager.loadLocal('achievements');
                if (saved) {
                    saved.forEach(s => {
                        const achievement = this.list.find(a => a.id === s.id);
                        if (achievement) achievement.unlocked = s.unlocked;
                    });
                }
            }
        };

        // ============================================
        // difficulty.js - Difficulty Manager
        // ============================================
        const DifficultyManager = {
            current: 'medium',

            getWords() {
                return CONFIG.WORDS[this.current] || CONFIG.WORDS.medium;
            },

            getRandomWord() {
                const words = this.getWords();
                return words[Math.floor(Math.random() * words.length)];
            },

            getMultiplier() {
                return CONFIG.DIFFICULTY_MULTIPLIERS[this.current] || 1.0;
            }
        };

        function selectDifficulty(difficulty) {
            DifficultyManager.current = difficulty;
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.difficulty === difficulty);
            });
        }

        // ============================================
        // ui-manager.js - UI Update Manager
        // ============================================
        const UIManager = {
            showError(message) {
                const errorEl = document.getElementById('humanError');
                errorEl.textContent = message;
                errorEl.classList.add('show');
                setTimeout(() => errorEl.classList.remove('show'), 2000);
            },

            updateDifficultyBadge(difficulty) {
                const badge = document.getElementById('humanDifficulty');
                if (badge) {
                    badge.textContent = difficulty.toUpperCase();
                    badge.className = `difficulty-badge ${difficulty}`;
                }
            },

            showThinking(show) {
                document.getElementById('aiThinking').classList.toggle('active', show);
            },

            updateGlobalStats(stats) {
                document.getElementById('globalGames').textContent = stats.totalGames || 0;
                const winRate = stats.totalGames > 0 
                    ? Math.round((stats.totalWins / stats.totalGames) * 100) 
                    : 0;
                document.getElementById('globalWinRate').textContent = winRate + '%';
                const avgGuesses = stats.totalGames > 0
                    ? (stats.totalGuesses / stats.totalGames).toFixed(1)
                    : 0;
                document.getElementById('globalAvgGuesses').textContent = avgGuesses;
            }
        };

        // ============================================
        // grid-manager.js - Grid Management
        // ============================================
        const GridManager = {
            create(containerId) {
                const container = document.getElementById(containerId);
                container.innerHTML = '';
                for (let i = 0; i < CONFIG.MAX_GUESSES; i++) {
                    const row = document.createElement('div');
                    row.className = 'grid-row';
                    for (let j = 0; j < CONFIG.WORD_LENGTH; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        row.appendChild(cell);
                    }
                    container.appendChild(row);
                }
            },

            update(containerId) {
                const cells = document.querySelectorAll(`#${containerId} .grid-cell`);
                const row = gameState.currentRow;

                for (let i = 0; i < CONFIG.WORD_LENGTH; i++) {
                    const cell = cells[row * CONFIG.WORD_LENGTH + i];
                    if (i < gameState.currentGuess.length) {
                        cell.textContent = gameState.currentGuess[i].toUpperCase();
                        cell.classList.add('filled');
                    } else {
                        cell.textContent = '';
                        cell.classList.remove('filled');
                    }
                }
            },

            shake(containerId, rowIndex) {
                const cells = document.querySelectorAll(`#${containerId} [data-row="${rowIndex}"]`);
                cells.forEach(cell => {
                    cell.classList.add('shake');
                    setTimeout(() => cell.classList.remove('shake'), 500);
                });
            },

            animateGuess(callback) {
                const containerId = gameState.mode === 'human' ? 'humanGrid' : 'aiGrid';
                const cells = document.querySelectorAll(`#${containerId} [data-row="${gameState.currentRow}"]`);

                anime({
                    targets: cells,
                    scale: [1, 1.1, 1],
                    rotateX: [0, 360],
                    duration: 500,
                    delay: anime.stagger(100),
                    easing: 'easeInOutQuad',
                    complete: callback
                });
            },

            checkGuess(guess) {
                const containerId = gameState.mode === 'human' ? 'humanGrid' : 'aiGrid';
                const cells = document.querySelectorAll(`#${containerId} [data-row="${gameState.currentRow}"]`);
                const target = gameState.targetWord;
                const letterCount = {};

                // Count letters in target
                for (let char of target) {
                    letterCount[char] = (letterCount[char] || 0) + 1;
                }

                // First pass: mark correct positions
                for (let i = 0; i < CONFIG.WORD_LENGTH; i++) {
                    if (guess[i] === target[i]) {
                        cells[i].classList.add('correct');
                        KeyboardManager.update(guess[i], 'correct');
                        gameState.clues.correct[i] = guess[i];
                        letterCount[guess[i]]--;
                    }
                }

                // Second pass: mark present and absent
                for (let i = 0; i < CONFIG.WORD_LENGTH; i++) {
                    if (guess[i] !== target[i]) {
                        if (target.includes(guess[i]) && letterCount[guess[i]] > 0) {
                            cells[i].classList.add('present');
                            KeyboardManager.update(guess[i], 'present');
                            gameState.clues.present.add(guess[i]);
                            letterCount[guess[i]]--;
                        } else {
                            cells[i].classList.add('absent');
                            KeyboardManager.update(guess[i], 'absent');
                            gameState.clues.absent.add(guess[i]);
                        }
                    }
                }
            }
        };

        // ============================================
        // keyboard-manager.js - Keyboard Management
        // ============================================
        const KeyboardManager = {
            create() {
                const keyboard = document.getElementById('keyboard');
                const rows = [
                    ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
                    ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
                    ['ENTER', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', 'BACK']
                ];

                keyboard.innerHTML = '';
                rows.forEach(row => {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'keyboard-row';
                    row.forEach(key => {
                        const keyBtn = document.createElement('button');
                        keyBtn.className = 'key' + (key.length > 1 ? ' wide' : '');
                        keyBtn.textContent = key === 'BACK' ? '‚å´' : key;
                        keyBtn.dataset.key = key;
                        keyBtn.onclick = () => this.handleKey(key);
                        rowDiv.appendChild(keyBtn);
                    });
                    keyboard.appendChild(rowDiv);
                });
            },

            handleKey(key) {
                if (gameState.gameOver) return;

                if (key === 'ENTER') {
                    GameController.submitGuess();
                } else if (key === 'BACK') {
                    gameState.currentGuess = gameState.currentGuess.slice(0, -1);
                } else if (gameState.currentGuess.length < CONFIG.WORD_LENGTH) {
                    gameState.currentGuess += key.toLowerCase();
                }

                GridManager.update('humanGrid');
            },

            update(letter, state) {
                const key = document.querySelector(`[data-key="${letter.toUpperCase()}"]`);
                if (!key) return;

                const currentState = gameState.keyboardState[letter];
                const priority = { correct: 3, present: 2, absent: 1 };

                if (!currentState || priority[state] > priority[currentState]) {
                    key.classList.remove('correct', 'present', 'absent');
                    key.classList.add(state);
                    gameState.keyboardState[letter] = state;
                    
                    // Disable absent keys
                    if (state === 'absent') {
                        key.disabled = true;
                        key.classList.add('disabled');
                    }
                }
            },

            reset() {
                document.querySelectorAll('.key').forEach(key => {
                    key.classList.remove('correct', 'present', 'absent', 'disabled');
                    key.disabled = false;
                });
                gameState.keyboardState = {};
            }
        };

        // ============================================
        // ai-strategy.js - Advanced AI Strategy
        // ============================================
        const AIStrategy = {
            // Get available words based on clues
            getAvailableWords() {
                return ALL_WORDS.filter(word => {
                    // Check correct positions
                    for (let pos in gameState.clues.correct) {
                        if (word[pos] !== gameState.clues.correct[pos]) {
                            return false;
                        }
                    }

                    // Check present letters (must be in word but not in same position)
                    for (let letter of gameState.clues.present) {
                        if (!word.includes(letter)) {
                            return false;
                        }
                    }

                    // Check absent letters (must not be in word)
                    for (let letter of gameState.clues.absent) {
                        // Only exclude if not already confirmed as present
                        if (!gameState.clues.present.has(letter)) {
                            if (word.includes(letter)) {
                                return false;
                            }
                        }
                    }

                    // Additional validation: present letters shouldn't be in same position
                    for (let i = 0; i < word.length; i++) {
                        if (gameState.clues.present.has(word[i])) {
                            // Check if this letter was marked as present from this position
                            for (let guess of gameState.guesses) {
                                if (guess[i] === word[i] && gameState.targetWord[i] !== word[i]) {
                                    return false;
                                }
                            }
                        }
                    }

                    return true;
                });
            },

            // Calculate word score with advanced algorithms
            calculateScore(word) {
                let score = 0;
                const seenLetters = new Set();

                // Strategy 1: Letter Frequency (with priority to yellow letters)
                for (let i = 0; i < word.length; i++) {
                    const char = word[i];
                    
                    // HIGH PRIORITY: Bonus for present (yellow) letters
                    if (gameState.clues.present.has(char)) {
                        score += 50; // Strong bonus for using yellow clues
                    }
                    
                    // Keep green letters in same position
                    if (gameState.clues.correct[i] === char) {
                        score += 100; // Maximum bonus for correct position
                    }
                    
                    // Penalty for using absent (black) letters
                    if (gameState.clues.absent.has(char)) {
                        score -= 100; // Strong penalty
                        continue;
                    }
                    
                    if (!seenLetters.has(char)) {
                        score += (aiState.letterFrequency[char] || 0) * 10;
                        seenLetters.add(char);
                    }

                    // Strategy 2: Position-based frequency
                    if (aiState.positionFrequency[i] && aiState.positionFrequency[i][char]) {
                        score += aiState.positionFrequency[i][char] * 5;
                    }
                }

                // Strategy 3: Word history score
                if (aiState.wordScores[word]) {
                    score *= aiState.wordScores[word];
                }

                // Strategy 4: Unique letters (early game)
                if (gameState.currentRow < 2) {
                    score += seenLetters.size * 8;
                }

                return score;
            },

            // Get best guess using all strategies
            getBestGuess() {
                const availableWords = this.getAvailableWords();
                
                if (availableWords.length === 0) {
                    return ALL_WORDS[Math.floor(Math.random() * ALL_WORDS.length)];
                }

                if (gameState.currentRow === 0) {
                    // First guess: use best starting word
                    return aiState.wordScores['arose'] !== undefined ? 'arose' : 
                           aiState.wordScores['soare'] !== undefined ? 'soare' : 
                           availableWords[0];
                }

                const probabilities = availableWords.map(word => ({
                    word,
                    score: this.calculateScore(word)
                }));

                probabilities.sort((a, b) => b.score - a.score);
                aiState.currentProbabilities = probabilities.slice(0, 10);

                // Track strategy effectiveness
                if (probabilities[0].score > 100) {
                    aiState.strategyEffectiveness.positionBased++;
                }

                // Use top choices with some randomness
                const topChoices = probabilities.slice(0, Math.min(3, probabilities.length));
                const totalScore = topChoices.reduce((sum, item) => sum + Math.max(item.score, 1), 0);
                let random = Math.random() * totalScore;
                
                for (let choice of topChoices) {
                    random -= Math.max(choice.score, 1);
                    if (random <= 0) {
                        return choice.word;
                    }
                }

                return topChoices[0].word;
            }
        };

        // ============================================
        // neural-network.js - Neural Network Visualization
        // ============================================
        const NeuralNetworkViz = {
            canvas: null,
            ctx: null,
            layers: [26, 64, 32, 5],
            nodes: [],
            connections: [],
            animationFrame: null,

            init() {
                this.canvas = document.getElementById('neuralCanvas');
                if (!this.canvas) return;
                
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = 400;
                
                this.setupNetwork();
                this.animate();
            },

            setupNetwork() {
                this.nodes = [];
                this.connections = [];
                
                const width = this.canvas.width;
                const height = this.canvas.height;
                const layerSpacing = width / (this.layers.length + 1);

                // Create nodes
                this.layers.forEach((nodeCount, layerIndex) => {
                    const nodeSpacing = height / (nodeCount + 1);
                    const displayCount = Math.min(nodeCount, 10);
                    
                    for (let i = 0; i < displayCount; i++) {
                        this.nodes.push({
                            x: layerSpacing * (layerIndex + 1),
                            y: (height / (displayCount + 1)) * (i + 1),
                            layer: layerIndex,
                            activation: Math.random(),
                            targetActivation: Math.random()
                        });
                    }
                });

                // Create connections (sample)
                for (let i = 0; i < this.nodes.length - 1; i++) {
                    const node = this.nodes[i];
                    const nextLayerNodes = this.nodes.filter(n => n.layer === node.layer + 1);
                    
                    nextLayerNodes.forEach(nextNode => {
                        if (Math.random() > 0.7) {
                            this.connections.push({
                                from: node,
                                to: nextNode,
                                weight: Math.random() * 2 - 1,
                                active: false
                            });
                        }
                    });
                }
            },

            animate() {
                if (!this.ctx) return;
                
                this.ctx.fillStyle = '#0d1117';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Update activations
                this.nodes.forEach(node => {
                    node.activation += (node.targetActivation - node.activation) * 0.1;
                    if (Math.random() < 0.02) {
                        node.targetActivation = Math.random();
                    }
                });

                // Draw connections
                this.connections.forEach(conn => {
                    const alpha = Math.abs(conn.weight) * conn.from.activation * 0.5;
                    this.ctx.strokeStyle = conn.weight > 0 
                        ? `rgba(88, 166, 255, ${alpha})` 
                        : `rgba(248, 81, 73, ${alpha})`;
                    this.ctx.lineWidth = Math.abs(conn.weight) * 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(conn.from.x, conn.from.y);
                    this.ctx.lineTo(conn.to.x, conn.to.y);
                    this.ctx.stroke();
                });

                // Draw nodes
                this.nodes.forEach(node => {
                    const radius = 8 + node.activation * 4;
                    const gradient = this.ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, radius);
                    gradient.addColorStop(0, `rgba(88, 166, 255, ${node.activation})`);
                    gradient.addColorStop(1, `rgba(88, 166, 255, 0)`);
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#58a6ff';
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // Draw layer labels
                this.ctx.fillStyle = '#8b949e';
                this.ctx.font = '12px monospace';
                this.ctx.textAlign = 'center';
                const labels = ['Input', 'Hidden 1', 'Hidden 2', 'Output'];
                labels.forEach((label, i) => {
                    const x = (this.canvas.width / (labels.length + 1)) * (i + 1);
                    this.ctx.fillText(label, x, 20);
                });

                this.animationFrame = requestAnimationFrame(() => this.animate());
            },

            triggerActivity() {
                this.nodes.forEach(node => {
                    node.targetActivation = Math.random();
                });
            },

            stop() {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
            }
        };

        // ============================================
        // ai-core.js - AI Core Logic
        // ============================================
        const AICore = {
            model: null,

            async initialize() {
                // Initialize letter frequency
                aiState.letterFrequency = {};
                aiState.positionFrequency = [{}, {}, {}, {}, {}];
                
                for (let word of ALL_WORDS) {
                    for (let i = 0; i < word.length; i++) {
                        const char = word[i];
                        aiState.letterFrequency[char] = (aiState.letterFrequency[char] || 0) + 1;
                        aiState.positionFrequency[i][char] = (aiState.positionFrequency[i][char] || 0) + 1;
                    }
                }

                // Normalize frequencies
                const maxFreq = Math.max(...Object.values(aiState.letterFrequency));
                for (let char in aiState.letterFrequency) {
                    aiState.letterFrequency[char] /= maxFreq;
                }

                // Initialize word scores
                for (let word of ALL_WORDS) {
                    if (!aiState.wordScores[word]) {
                        aiState.wordScores[word] = 1.0;
                    }
                }

                // Load saved progress
                const saved = await StorageManager.loadAIProgress();
                if (saved) {
                    aiState.gamesPlayed = saved.gamesPlayed || 0;
                    aiState.wins = saved.wins || 0;
                    aiState.totalGuesses = saved.totalGuesses || 0;
                    aiState.performanceHistory = saved.performanceHistory || [];
                    aiState.wordScores = { ...aiState.wordScores, ...saved.wordScores };
                    aiState.strategyEffectiveness = saved.strategyEffectiveness || {
                        positionBased: 0,
                        frequencyBased: 0,
                        eliminationBased: 0
                    };
                }

                // Create TensorFlow model
                this.model = tf.sequential({
                    layers: [
                        tf.layers.dense({ inputShape: [26], units: 64, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 32, activation: 'relu' }),
                        tf.layers.dense({ units: 5, activation: 'softmax' })
                    ]
                });

                this.model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                });

                console.log('‚úÖ AI Core initialized');
            },

            async play() {
                if (gameState.gameOver) return;

                UIManager.showThinking(true);
                NeuralNetworkViz.triggerActivity();

                await new Promise(resolve => 
                    setTimeout(resolve, CONFIG.AI_THINK_TIME.min + Math.random() * 
                    (CONFIG.AI_THINK_TIME.max - CONFIG.AI_THINK_TIME.min))
                );

                const guess = AIStrategy.getBestGuess();
                gameState.currentGuess = guess;
                GridManager.update('aiGrid');

                UIManager.showThinking(false);

                await new Promise(resolve => setTimeout(resolve, 500));

                gameState.guesses.push(guess);
                GridManager.animateGuess(() => {
                    GridManager.checkGuess(guess);
                    gameState.currentGuess = '';
                    gameState.currentRow++;

                    if (guess === gameState.targetWord) {
                        GameController.endGame(true);
                    } else if (gameState.currentRow >= CONFIG.MAX_GUESSES) {
                        GameController.endGame(false);
                    } else {
                        setTimeout(() => this.play(), 1000);
                    }
                });

                GraphManager.updateAll();
            },

            async updateStats(won) {
                aiState.gamesPlayed++;
                if (won) aiState.wins++;
                aiState.totalGuesses += gameState.currentRow;

                aiState.performanceHistory.push({
                    game: aiState.gamesPlayed,
                    guesses: gameState.currentRow,
                    won: won,
                    difficulty: gameState.difficulty,
                    timestamp: Date.now()
                });

                // Update word scores based on performance
                for (let guess of gameState.guesses) {
                    const performance = won ? 1.05 : 0.95;
                    aiState.wordScores[guess] = (aiState.wordScores[guess] || 1.0) * performance;
                }

                await this.trainModel();
                await this.saveProgress();
                
                // Update global stats
                const globalStats = await StorageManager.loadGlobalStats();
                globalStats.totalGames = (globalStats.totalGames || 0) + 1;
                globalStats.totalWins = (globalStats.totalWins || 0) + (won ? 1 : 0);
                globalStats.totalGuesses = (globalStats.totalGuesses || 0) + gameState.currentRow;
                await StorageManager.saveGlobalStats(globalStats);
                UIManager.updateGlobalStats(globalStats);
                
                this.updateStatsDisplay();
            },

            async trainModel() {
                const inputs = [];
                const outputs = [];
                const recentGames = aiState.performanceHistory.slice(-50);
                
                for (let game of recentGames) {
                    const input = new Array(26).fill(0);
                    const output = new Array(5).fill(game.won ? 0.8 : 0.2);
                    inputs.push(input);
                    outputs.push(output);
                }

                if (inputs.length > 10) {
                    const xs = tf.tensor2d(inputs);
                    const ys = tf.tensor2d(outputs);

                    await this.model.fit(xs, ys, {
                        epochs: 5,
                        batchSize: 8,
                        verbose: 0
                    });

                    xs.dispose();
                    ys.dispose();
                }
            },

            updateStatsDisplay() {
                document.getElementById('gamesPlayed').textContent = aiState.gamesPlayed;
                
                const winRate = aiState.gamesPlayed > 0 
                    ? Math.round((aiState.wins / aiState.gamesPlayed) * 100) 
                    : 0;
                document.getElementById('winRate').textContent = winRate + '%';
                
                const avgGuesses = aiState.gamesPlayed > 0
                    ? (aiState.totalGuesses / aiState.gamesPlayed).toFixed(1)
                    : 0;
                document.getElementById('avgGuesses').textContent = avgGuesses;
                
                const learningProgress = Math.min(100, aiState.gamesPlayed * 2);
                document.getElementById('learningRate').textContent = learningProgress + '%';
                
                const strategyTotal = Object.values(aiState.strategyEffectiveness)
                    .reduce((a, b) => a + b, 0);
                document.getElementById('strategyScore').textContent = strategyTotal;
            },

            async saveProgress() {
                const data = {
                    gamesPlayed: aiState.gamesPlayed,
                    wins: aiState.wins,
                    totalGuesses: aiState.totalGuesses,
                    performanceHistory: aiState.performanceHistory,
                    wordScores: aiState.wordScores,
                    strategyEffectiveness: aiState.strategyEffectiveness
                };
                await StorageManager.saveAIProgress(data);
            }
        };

        // ============================================
        // graphs.js - Graph Visualizations
        // ============================================
        const GraphManager = {
            updateAll() {
                this.updateProbability();
                this.updatePerformance();
                this.updateLetterHeatmap();
                this.updateStrategy();
            },

            updateProbability() {
                const data = aiState.currentProbabilities.length > 0
                    ? aiState.currentProbabilities.slice(0, 8)
                    : ALL_WORDS.slice(0, 8).map(word => ({ word, score: Math.random() * 100 }));

                const trace = {
                    x: data.map(d => d.word.toUpperCase()),
                    y: data.map(d => d.score),
                    type: 'bar',
                    marker: {
                        color: data.map(d => d.score),
                        colorscale: [
                            [0, '#30363d'],
                            [0.5, '#58a6ff'],
                            [1, '#2ea043']
                        ],
                        line: {
                            color: '#58a6ff',
                            width: 2
                        }
                    }
                };

                const layout = {
                    paper_bgcolor: '#0d1117',
                    plot_bgcolor: '#0d1117',
                    font: { color: '#c9d1d9' },
                    xaxis: { 
                        gridcolor: '#30363d',
                        title: 'Top Word Candidates'
                    },
                    yaxis: { 
                        gridcolor: '#30363d',
                        title: 'Probability Score'
                    },
                    margin: { t: 20, b: 60, l: 60, r: 20 }
                };

                Plotly.newPlot('probabilityGraph', [trace], layout, { responsive: true });
            },

            updatePerformance() {
                const history = aiState.performanceHistory.length > 0
                    ? aiState.performanceHistory.slice(-20)
                    : Array.from({ length: 10 }, (_, i) => ({ 
                        game: i + 1, 
                        guesses: Math.floor(Math.random() * 3) + 3,
                        won: Math.random() > 0.3
                      }));

                const trace = {
                    x: history.map(h => h.game),
                    y: history.map(h => h.guesses),
                    type: 'scatter',
                    mode: 'lines+markers',
                    line: { 
                        color: '#58a6ff',
                        width: 3,
                        shape: 'spline'
                    },
                    marker: {
                        size: 10,
                        color: history.map(h => h.won ? '#2ea043' : '#f85149'),
                        line: {
                            color: '#c9d1d9',
                            width: 2
                        }
                    }
                };

                const layout = {
                    paper_bgcolor: '#0d1117',
                    plot_bgcolor: '#0d1117',
                    font: { color: '#c9d1d9' },
                    xaxis: { 
                        gridcolor: '#30363d',
                        title: 'Game Number'
                    },
                    yaxis: { 
                        gridcolor: '#30363d',
                        title: 'Guesses to Solve',
                        range: [0, 7]
                    },
                    margin: { t: 20, b: 60, l: 60, r: 20 }
                };

                Plotly.newPlot('performanceGraph', [trace], layout, { responsive: true });
            },

            updateLetterHeatmap() {
                const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                const positions = ['P1', 'P2', 'P3', 'P4', 'P5'];
                
                const zData = positions.map((_, posIdx) => 
                    letters.map(letter => 
                        (aiState.positionFrequency[posIdx][letter.toLowerCase()] || 0)
                    )
                );

                const trace = {
                    z: zData,
                    x: letters,
                    y: positions,
                    type: 'heatmap',
                    colorscale: [
                        [0, '#0d1117'],
                        [0.5, '#1f6feb'],
                        [1, '#2ea043']
                    ],
                    showscale: true
                };

                const layout = {
                    paper_bgcolor: '#0d1117',
                    plot_bgcolor: '#0d1117',
                    font: { color: '#c9d1d9' },
                    xaxis: { 
                        title: 'Letters',
                        side: 'bottom'
                    },
                    yaxis: { 
                        title: 'Position in Word'
                    },
                    margin: { t: 20, b: 60, l: 60, r: 20 }
                };

                Plotly.newPlot('letterHeatmap', [trace], layout, { responsive: true });
            },

            updateStrategy() {
                const strategies = [
                    { name: 'Position Based', value: aiState.strategyEffectiveness.positionBased },
                    { name: 'Frequency Based', value: aiState.strategyEffectiveness.frequencyBased },
                    { name: 'Elimination Based', value: aiState.strategyEffectiveness.eliminationBased }
                ];

                const trace = {
                    labels: strategies.map(s => s.name),
                    values: strategies.map(s => s.value || 1),
                    type: 'pie',
                    marker: {
                        colors: ['#58a6ff', '#2ea043', '#9e6a03']
                    },
                    textinfo: 'label+percent',
                    textfont: {
                        color: '#c9d1d9'
                    }
                };

                const layout = {
                    paper_bgcolor: '#0d1117',
                    plot_bgcolor: '#0d1117',
                    font: { color: '#c9d1d9' },
                    showlegend: true,
                    legend: {
                        font: { color: '#c9d1d9' }
                    },
                    margin: { t: 20, b: 20, l: 20, r: 20 }
                };

                Plotly.newPlot('strategyGraph', [trace], layout, { responsive: true });
            }
        };

        // ============================================
        // main.js - Game Controller
        // ============================================
        const GameController = {
            submitGuess() {
                if (gameState.currentGuess.length !== CONFIG.WORD_LENGTH) return;
                
                if (!ALL_WORDS.includes(gameState.currentGuess)) {
                    UIManager.showError('‚ö† Word not in list!');
                    GridManager.shake('humanGrid', gameState.currentRow);
                    return;
                }

                const guess = gameState.currentGuess;
                gameState.guesses.push(guess);

                GridManager.animateGuess(() => {
                    GridManager.checkGuess(guess);
                    gameState.currentGuess = '';
                    gameState.currentRow++;

                    if (guess === gameState.targetWord) {
                        this.endGame(true);
                    } else if (gameState.currentRow >= CONFIG.MAX_GUESSES) {
                        this.endGame(false);
                    }
                });
            },

            endGame(won) {
                gameState.gameOver = true;
                const statusId = gameState.mode === 'human' ? 'humanStatus' : 'aiStatus';
                const status = document.getElementById(statusId);
                const title = status.querySelector('.status-title');
                const word = status.querySelector('.status-word');

                status.classList.add('active', won ? 'win' : 'lose');
                title.textContent = won ? 'üéâ ' + (gameState.mode === 'human' ? 'YOU WIN!' : 'AI WINS!') : 'üòû GAME OVER';
                word.innerHTML = `The word was: <strong>${gameState.targetWord.toUpperCase()}</strong>`;

                if (gameState.mode === 'ai') {
                    AICore.updateStats(won);
                } else {
                    // Check achievements
                    if (won) {
                        Achievements.check('first_win');
                        if (gameState.currentRow <= 3) {
                            Achievements.check('perfect_game');
                        }
                        if (gameState.difficulty === 'expert') {
                            Achievements.check('expert_solver');
                        }
                    }
                    Achievements.render();
                }
            }
        };

        // ============================================
        // Game Functions
        // ============================================
        function startGame(mode) {
            gameState = {
                mode: mode,
                difficulty: DifficultyManager.current,
                targetWord: DifficultyManager.getRandomWord(),
                currentRow: 0,
                currentGuess: '',
                guesses: [],
                gameOver: false,
                keyboardState: {},
                clues: {
                    correct: {},
                    present: new Set(),
                    absent: new Set()
                }
            };

            console.log('üéØ Target word:', gameState.targetWord);

            document.getElementById('homeScreen').style.display = 'none';
            document.getElementById('humanScreen').style.display = mode === 'human' ? 'block' : 'none';
            document.getElementById('aiScreen').style.display = mode === 'ai' ? 'block' : 'none';

            const gridId = mode === 'human' ? 'humanGrid' : 'aiGrid';
            GridManager.create(gridId);

            if (mode === 'human') {
                KeyboardManager.reset();
                UIManager.updateDifficultyBadge(gameState.difficulty);
            }

            if (mode === 'ai') {
                NeuralNetworkViz.init();
                setTimeout(() => AICore.play(), 1000);
            }
        }

        function resetGame(mode) {
            const statusId = mode === 'human' ? 'humanStatus' : 'aiStatus';
            document.getElementById(statusId).classList.remove('active', 'win', 'lose');
            
            if (mode === 'ai') {
                NeuralNetworkViz.stop();
            }
            
            startGame(mode);
        }

        function goHome() {
            document.getElementById('homeScreen').style.display = 'flex';
            document.getElementById('humanScreen').style.display = 'none';
            document.getElementById('aiScreen').style.display = 'none';
            document.getElementById('aiAnalytics').classList.remove('expanded');
            NeuralNetworkViz.stop();
        }

        function toggleAnalytics() {
            const analytics = document.getElementById('aiAnalytics');
            const btnText = document.getElementById('analyticsToggleText');
            
            analytics.classList.toggle('expanded');
            
            if (analytics.classList.contains('expanded')) {
                btnText.textContent = 'Hide Analytics';
                GraphManager.updateAll();
                if (!NeuralNetworkViz.canvas) {
                    NeuralNetworkViz.init();
                }
            } else {
                btnText.textContent = 'Show Analytics';
            }
        }

        // Keyboard event listener
        document.addEventListener('keydown', (e) => {
            if (gameState.mode !== 'human' || gameState.gameOver) return;

            if (e.key === 'Enter') {
                KeyboardManager.handleKey('ENTER');
            } else if (e.key === 'Backspace') {
                KeyboardManager.handleKey('BACK');
            } else if (/^[a-zA-Z]$/.test(e.key)) {
                KeyboardManager.handleKey(e.key.toUpperCase());
            }
        });

        // ============================================
        // Initialize Everything
        // ============================================
        async function init() {
            console.log('üöÄ Initializing Advanced Word Master AI...');
            
            KeyboardManager.create();
            await AICore.initialize();
            AICore.updateStatsDisplay();
            Achievements.load();
            Achievements.render();
            
            // Load and display global stats
            const globalStats = await StorageManager.loadGlobalStats();
            UIManager.updateGlobalStats(globalStats);
            
            console.log('‚úÖ Game ready!');
        }

        // Start the game
        init();
    </script>
</body>
</html>
